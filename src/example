//%precondition b % 4 == 2
//%postcondition c - 2 == 1
fn a (b: i32, c:bool, a: i32 ) -> bool {
let mut temp: [i32; 4] = [1,2,3, 4];
let x_d = temp;
let mut a: i32 = 14;

let lol = x_d[a];
// just ignore me

// the one below is not to be ignored
//the one below is not to be ignored
//%assert a == 14
//%assume b %2 == 1


// Tuple
let b: (bool, i32) = (true, 12);
let c  = b.0;
let (c, _)  = (true, 13);
let (c, _)  = b;

c  = b.0;
(c, _)  = (true, 13);
(c, _)  = b;
// Do we really need to handle this, instead of using just `let __t = fcall(args); let (c, _) = __t;`
//let (c, _)  = xd(a, lc);


a = xd(a, lc, true, 12, 143);
/*
this
also
does not
matter
at all */let b: bool;
// this is just a normal comment
//%loop_invariant c== 3
if a == 14 {
   let mut c = 3;
} else if a == 13 {
   let c = a + 43;
} else {
   let c = a + 123;
}
}