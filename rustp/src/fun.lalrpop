use std::str::FromStr;
use crate::ast::{Expr, Opcode, Function, Clause}; // (0)

grammar;

pub Functions: Vec<Function> = {
    Function => vec![<>],
    <mut b: Functions> <a:Function> => {b.push(a); b},
};

pub Function: Function = {
    "function" <n:Name> "{" <c:Clauses> "}" => Function{name: n, content: c},
};

pub Clauses: Vec<Clause> = {
    Clause => vec![*<>],
    <mut b:Clauses> <a:Clause> => {b.push(*a); b},
};

pub Clause: Box<Clause> = { // (1)
    Expr => Box::new(Clause::Expr(*<>)),
    Assert => <>,
};

pub Assert: Box<Clause> = {
    "assert" "{" <a:Whatever> "}" => Box::new(Clause::Assert(a)),
}

pub Exprs: Vec<Expr> = {
    Expr => vec![*<>],
    <mut b:Exprs> <a:Expr> => {b.push(*a); b},
};

pub Expr: Box<Expr> = { // (1)
    Expr ExprOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

ExprOp: Opcode = { // (3)
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)), // (4)
    "(" <Expr> ")"
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Name: String = {
    r"[a-z]+" => <>.to_string()
};

Whatever: String = {
    <a:r"ZZZ"> => a.to_string()
};